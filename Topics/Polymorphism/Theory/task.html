<div class="step-text">
<h5 id="kinds-of-polymorphism" style="text-align: center;">Kinds of polymorphism</h5>
<p>In general, <strong>polymorphism</strong> means that something (an object or another entity) has many forms.</p>
<p>Java provides two types of polymorphism: <strong>static (<a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a compile is the process of translating source code into bytecode that can be executed by the Java Virtual Machine (JVM). | During compilation, the Java compiler checks the code for errors, such as typos, incorrect method invocations, and mismatched variable declarations. If any errors are found, the code will not compile and an error message will be generated. To avoid compile-time errors, programmers can use tools like Integrated Development Environments (IDEs) with static code analyzers, which can identify and highlight potential errors before the code is compiled.">compile</a>-time)</strong> and <strong>dynamic</strong> <strong>(run-time) </strong>polymorphism. The first one is achieved by <strong><a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, method overloading is a feature that allows you to create multiple methods with the same name but different parameter types or number of parameters. | When a method is called, the Java compiler determines which version of the method to execute based on the type, number, and order of the arguments provided. This mechanism enables you to create more concise and easier-to-understand code while handling various inputs. Method overloading enhances code readability and maintainability, promotes code reuse, and makes it more versatile.">method overloading</a></strong>, the second one is based on inheritance and <strong><a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, method overriding is a mechanism that allows a subclass to provide a specific implementation of a method that is already provided by its superclass. | The name and parameter of the overriding method in the subclass must be exactly the same as the method in the superclass. However, the return type can be the same as the superclass method or a subtype of it, which is known as the covariant return type. Method overriding enables subclasses to modify the behavior inherited from their superclass, giving it their own unique flair, similar to adding a special twist to a classic recipe.">method overriding</a></strong>.</p>
<p>The more theoretical approach subdivides polymorphism into several fundamentally different types:</p>
<ul>
<li><strong>Ad-hoc polymorphism</strong> refers to polymorphic functions that can be applied to arguments of different types, but behave differently depending on the type of the argument to which they are applied. Java supports it as <strong>method overloading</strong>.</li>
<li><strong><a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, subtype polymorphism, also known as dynamic (run-time) polymorphism, is a fundamental object-oriented design concept that allows a class to specify methods that will be common to all of its subclasses. | It enables subclasses to override the implementation of those methods, providing a way for objects of different classes to be treated as instances of a common superclass. This is achieved through dynamic method dispatching, where the method to be called is determined at run-time based on the actual object, rather than the type of the reference.">Subtype polymorphism</a></strong> (also known as subtyping) is a possibility to use an instance of a subclass when an instance of the <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a base class, also known as a superclass or parent class, is a class that is extended by another class, known as a subclass or derived class. | It serves as a blueprint for the subclass, providing it with inherited fields and methods. A parent class can have multiple child classes, but a child class can only have one parent class due to Java's single inheritance feature. The parent class reference can be used to refer to any subclass object derived from that superclass. An abstract class is often used as a base class in a hierarchy, and it represents an abstract concept that is used as a base class for subclasses.">base class</a> is permitted.</li>
<li><strong>Parametric polymorphism </strong>is when the code is written without mention of any specific type and thus can be used transparently with any number of new types. Java supports it as <strong>generics</strong> or <strong>generic programming</strong>.</li>
</ul>
<p>In this topic, we consider only <strong>subtype (<a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a runtime, also known as runtime environment or runtime system, refers to the environment in which a Java program is executed. | It includes the Java Virtual Machine (JVM), which interprets the bytecode of the program, and the Java Class Library, which provides a set of prewritten classes that can be used in Java programs. The runtime environment is responsible for managing system resources, loading classes, handling exceptions, and executing the code.">runtime</a>) polymorphism</strong> that is widely used in <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, object-oriented programming (OOP) is a programming paradigm that revolves around the concept of objects, which can represent real-world entities or abstract concepts. | Each object has its own state, which is stored in fields, and behavior, which is defined by methods. Objects are instances of classes, which serve as blueprints that define the properties and methods of their corresponding objects. OOP emphasizes encapsulation, inheritance, and polymorphism, making software design more reusable and maintainable. It is a good practice to use interface-oriented design, which means relying on interfaces instead of concrete implementations. Interfaces define a contract that classes must adhere to, allowing for greater flexibility and modularity in programming. Java is primarily an object-oriented programming language, but it also supports other programming paradigms, such as functional programming. OOP provides a way to create well-structured and readable programs by allowing developers to define the behavior of objects and classes using methods.">object-oriented</a> programming.</p>
<h5 id="runtime-polymorphic-behavior" style="text-align: center;">Runtime polymorphic behavior</h5>
<p>A reminder: <em>method overriding</em> is when a subclass redefines a method of the superclass with the same signature.</p>
<p>Run-time polymorphism relies on two principles:</p>
<ul>
<li>a reference variable of the superclass can refer to any subtype object;</li>
<li>a superclass method can be overridden in a subclass.</li>
</ul>
<p>Run-time polymorphism works when an overridden method is called through the reference variable of a superclass.<strong> </strong>Java determines at runtime which version of the method (superclass/subclasses) is to be executed based on the type of the object being referred, not the type of reference. It uses a mechanism known as <strong>dynamic method dispatching</strong>.</p>
<p><strong>Example. </strong>Here, you can see a <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a class hierarchy is a way of organizing classes in a parent-child relationship, where a child class inherits properties and methods from its parent class, also known as the superclass. | This mechanism enables code reuse and facilitates the building of a class hierarchy. In the context of a company's activity, for example, a class hierarchy could include a base class with common data fields such as name, year of birth, and address. Derived classes could then add additional fields specific to their purpose, such as a contract number and status for a client class, or start date of work and salary for an employee class. In Java, a class can only inherit from one superclass, but a superclass can have multiple subclasses. It's important to note that constructors are not inherited, but the superclass's constructor can be invoked from the subclass. When working with class hierarchies, you can refer to a subclass object in two ways: using a subclass reference or using a superclass reference. The latter allows you to refer to any subclass using a superclass reference variable.">class hierarchy</a>. The superclass <code class="language-java">MythicalAnimal</code> has two subclasses: <code class="language-java">Chimera</code> and <code class="language-java">Dragon</code>. The base class has a method <code class="language-java">hello</code>. Both subclasses override this method.</p>
<pre><code class="language-java">class MythicalAnimal {    

    public void hello() {
        System.out.println("Hello, I'm an unknown animal");
    }
}

class Chimera extends MythicalAnimal {
    @Override
    public void hello() {
        System.out.println("Hello! Hello!");
    }
}

class Dragon extends MythicalAnimal {
    @Override
    public void hello() {
        System.out.println("Rrrr...");
    }
}</code></pre>
<p>We can create a reference to the class <code class="language-java">MythicalAnimal</code> and assign the subclass object to it:</p>
<pre><code class="language-java">MythicalAnimal chimera = new Chimera();
MythicalAnimal dragon = new Dragon();
MythicalAnimal animal = new MythicalAnimal();</code></pre>
<p>We can also invoke overridden methods through the base class references:</p>
<pre><code class="language-java">chimera.hello(); // Hello! Hello!
dragon.hello(); // Rrrr...
animal.hello(); // Hello, I'm an unknown animal</code></pre>
<p>So, the result of a method call depends on the actual type of an instance, not the <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a reference type is a type of variable that stores a reference to an object located elsewhere in memory, rather than storing the object's value directly. | When an object is created using the new operator, it returns a reference to the location of the object in memory, allowing access to its fields and methods. Reference types can be assigned to variables, passed as arguments to methods, and returned as values from methods. They are important for creating complex, object-oriented programs in Java. Unlike primitive types, which store their values directly, reference types store a reference to an object. When comparing reference types using the == operator, it compares the references (memory addresses) rather than the actual values. Additionally, assigning one value of a reference variable to another creates a copy of the reference, rather than the value itself. Reference types can also refer to a special value that represents the fact that it is not initialized yet or does not have a value. It is important to note that in Java, the heap is the region of memory where objects are stored and allocated dynamically during runtime.">reference type</a>. It's a polymorphic feature in Java. The JVM calls the appropriate method for the object that is referred to in each variable.</p>
<p>Subtype polymorphism allows a class to specify methods that will be common to all of its subclasses. Subtype polymorphism also makes it possible for subclasses to override the implementations of those methods. Together with <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an abstract method is a method that is declared in an abstract class but does not contain an implementation. | It only includes a method signature, return type, and modifiers. The abstract keyword is used to declare an abstract method. Concrete subclasses of the abstract class must provide an implementation for these abstract methods. Since an abstract class cannot be instantiated, the purpose of an abstract method is to provide a common interface for its subclasses. If a class contains an abstract method, the class must be declared abstract as well.">abstract methods</a> and interfaces, which you'll learn about later, subtype polymorphism is a fundamental object-oriented design concept.</p>
<h5 id="polymorphism-within-a-class-hierarchy" style="text-align: center;">Polymorphism within a class hierarchy</h5>
<p>The same thing works with methods that are used only within a hierarchy and are not accessible from the outside.</p>
<p>In the following example, we have a hierarchy<strong> </strong>of files. The <a class="theory-lookup not-relevant" href="/learn/step/3587" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a parent class, also known as a superclass or base class, is a class that is extended by another class, known as a subclass or derived class. | It serves as a blueprint for the subclass, providing it with inherited fields and methods. A parent class can have multiple child classes, but a child class can only have one parent class due to Java's single inheritance feature. The parent class reference can be used to refer to a subclass object, allowing for polymorphism and code reuse.">parent class</a> <code class="language-java">File</code> represents a description of a single file in the file system. It has a subclass named <code class="language-java">ImageFile</code>.  It overrides the method <code class="language-java">getFileInfo</code> of the parent class.</p>
<pre><code class="language-java">class File {

    protected String fullName;

    // constructor with a single parameter

    // getters and setters

    public void printFileInfo() {
        String info = this.getFileInfo(); // here is polymorphic behavior!!!
        System.out.println(info);
    }

    protected String getFileInfo() {
        return "File: " + fullName;
    }
}

class ImageFile extends File {

    protected int width;
    protected int height;
    protected byte[] content;

    // constructor

    // getters and setters

    @Override
    protected String getFileInfo() {
        return String.format("Image: %s, width: %d, height: %d", fullName, width, height); 
    }
}</code></pre>
<p>The parent class has a public method <code class="language-java">printFileInfo</code> and a protected method <code class="language-java">getFileInfo</code>. The second method is overridden in the subclass, but the subclass doesn't override the first method.</p>
<p>Let's create an instance of <code class="language-java">ImageFile</code> and assign it to a variable of <code class="language-java">File</code>.</p>
<pre><code class="language-java">File img = new ImageFile("/path/to/file/img.png", 480, 640, someBytes); // assigning an object</code></pre>
<p>Now, when we call the method <code class="language-java">printFileInfo</code>, it invokes the overridden version of the method <code class="language-java">getFileInfo</code>.</p>
<pre><code class="language-java">img.printFileInfo(); // It prints "Image: /path/to/file/img.png, width: 480, height: 640"</code></pre>
<p>So, <strong>run-time polymorphism</strong> allows you to invoke an overridden method of a subclass having a reference to the base class.</p>
</div>